# EvalForge Roadmap â€“ Worlds, Modes & Codex

EvalForge is my personal **AI Training Arcade**: a gamified app that helps me grow into a **senior AI/ML full-stack engineer**.

Core ideas:

- Treat learning like a game (worlds, quests, XP, boss fights).
- Use **my real projects** (ApplyLens, LedgerMind, SiteAgent, EvalForge itself) as practice grounds.
- Use multiple **agents** (Explain, QuestMaster, Debugger, Judge, Visualizer) instead of a single chat.
- Make reference knowledge always available via a **Codex**.

This document is the **source of truth** for the current design and the implementation roadmap.

---

## 1. Conceptual Model

### 1.1 Universe â†’ Worlds â†’ Tracks â†’ Quests

- **Universe** = EvalForge.
- **Worlds** = themed â€œpagesâ€ focused on languages or stacks:
  - Python World, JavaScript World, TypeScript World, SQL World
  - PyTorch & ML World
  - Infra & Observability World (Docker, FastAPI, GCP, Prometheus, Grafana, Datadog)
  - Agents & Prompting World
  - Git & Workflows World (optional/later)

- **Tracks** = specific contexts inside a world, often tied to a real project:
  - Example (Python World): `ApplyLens â€“ Backend`, `LedgerMind â€“ ML Suggestions`
  - Example (Infra World): `ApplyLens â€“ Infra`, `SiteAgent â€“ Infra & SEO`

- **Quests** = concrete missions generated by the QuestMaster agent for a given world + track:
  - Debug a failing endpoint
  - Design a small feature
  - Improve tests & observability
  - Implement a new agent/tool

### 1.2 Modes (Agent Roles)

Each session runs in one of several **modes**, which map to different agents:

1. **Explain Mode (Teacher Agent)**
   - Goal: explain code / concepts clearly.
   - Behavior:
     - High-level summary
     - Step-by-step explanation
     - Concrete examples
     - Alternative approaches (not just one solution)
     - Common pitfalls

2. **Quest Mode (QuestMaster Agent)**
   - Goal: generate or manage quests.
   - Behavior:
     - Creates quests scoped to the current world + track
     - Includes story, requirements, acceptance criteria, suggested difficulty
     - Optionally suggests relevant Codex entries

3. **Debug Mode (Debugger Agent)**
   - Goal: help troubleshoot issues.
   - Behavior:
     - Asks clarifying questions
     - Proposes hypotheses
     - Suggests concrete probes (logs, curl, tests)
     - Uses a structured debugging plan instead of guessing

4. **Judge Mode (Grading Agent)**
   - Goal: evaluate solutions and give feedback.
   - Behavior:
     - Scores answers using a rubric (coverage / correctness / clarity)
     - Provides written feedback and suggestions
     - Grants XP toward skills and levels

5. **Visualizer Mode (later)**
   - Goal: generate diagrams and visual cues.
   - Behavior:
     - Produces sequence diagrams, architecture diagrams, or data flows
     - Uses text formats (Mermaid, ASCII) that can be rendered in the UI

### 1.3 Codex

The **Codex** is an always-available reference library (no agent interaction required).

- Stored as Markdown files in version control.
- Organized by world and topic:
  - `codex/python/*`
  - `codex/javascript/*`
  - `codex/typescript/*`
  - `codex/sql/*`
  - `codex/pytorch/*`
  - `codex/infra/*` (Docker, FastAPI, GCP)
  - `codex/observability/*` (Prometheus, Grafana, Datadog)
  - `codex/agents/*` (prompt patterns, evaluation patterns)
  - `codex/git/*` (commands, workflows, branching strategies)

Example Codex topics:
- Best coding practices by language
- Basic syntax & idioms
- Stack cheat sheets (React, Docker, FastAPI, GCP)
- Observability patterns (metrics, dashboards, SLOs)
- Prompting and agent design patterns
- Git commands & daily workflows

Codex entries can be linked from quests and explanations, but they are also browsable directly from a **Codex page** and from **world sidebars**.

### 1.4 XP, Levels, and Boss Fights

- Each world has its own **XP bar** and **level**.
- XP is granted primarily by the **Judge**:
  - Map rubric dimensions (coverage, correctness, clarity) to skills:
    - Debugging, Architecture, ML/Data, Infra/Systems, Communication
- Levels are derived from total XP (e.g. `level = floor(total_xp / 100)`).
- **Boss fights** are larger, multi-step quests:
  - Require a minimum XP to unlock
  - Use stricter judging criteria
  - Represent â€œhave I really internalized this topic/project?â€

---

## 2. Data Structures (High-Level)

### 2.1 Worlds (config)

Configuration file: `worlds.json` (or similar).

Example entry:

```json
{
  "id": "world-python",
  "name": "Python World",
  "themeColor": "#4B8BBE",
  "icon": "ğŸ",
  "description": "Backend, scripts, data, and ML in Python.",
  "defaultTracks": ["applylens-backend", "ledgermind-ml"]
}
```

### 2.2 Tracks

Configuration file: `tracks.json`.

Example entry:

```json
{
  "id": "applylens-backend",
  "name": "ApplyLens â€“ Backend",
  "worldId": "world-python",
  "description": "FastAPI, Gmail ingestion, Elasticsearch, Postgres, BigQuery",
  "repoUrl": "https://github.com/â€¦/applylens",
  "tags": ["python", "fastapi", "backend"]
}
```

### 2.3 Codex Entries

Stored as Markdown with frontmatter:

```markdown
---
id: python-basics-syntax
title: Python Basics â€“ Syntax Cheatsheet
worlds: ["world-python"]
tags: ["python", "syntax"]
skills: ["debug", "architecture"]
---

# Python Basics â€“ Syntax Cheatsheet

...
```

### 2.4 Profile / XP (simple version)

For now, a single user profile is fine:

```json
{
  "userId": "leo",
  "worldXp": {
    "world-python": 240,
    "world-js": 90,
    "world-infra": 150
  },
  "skills": {
    "debug": 120,
    "architecture": 80,
    "ml": 60,
    "infra": 40,
    "communication": 30
  }
}
```

---

## 3. Roadmap Phases

### Phase 0 â€“ Stabilize the Core (Mostly Done)

Goal: Stable server using Gemini 2.5 Flash with clear config.

- [x] Ensure Vertex config is correct: `EVALFORGE_VERTEX_MODEL=gemini-2.5-flash`, `EVALFORGE_VERTEX_LOCATION=us-central1`
- [x] Support mock mode for demos: `EVALFORGE_MOCK_GRADING=1`
- [x] Add a simple health endpoint: Expose provider, model, location, and mock flag.
- [x] Lock in a stable dev port (e.g. 8092) and document it.

Status: **done / ongoing**.

### Phase 1 â€“ Multi-Mode & Tracks (MVP 2.0 Core)

Goal: Move from single debug chat to modes + tracks.

**Backend**
- [ ] Introduce a generic `mode` parameter: `explain | quest | debug | judge`
- [ ] Implement a unified message endpoint, e.g.: `POST /api/session/{id}/message` with `{ mode, worldId, trackId, content }`.
- [ ] Create system prompts for:
  - Explain Mode (Teacher)
  - Quest Mode (QuestMaster)
  - Debug Mode (Debugger)
  - Reuse existing Judge prompt for Judge Mode.
- [ ] Add `tracks.json` and an endpoint: `GET /api/tracks` and `GET /api/tracks/{id}`.

**Frontend**
- [ ] Add track selector to the top bar.
- [ ] Add mode tabs: `Explain | Quest | Debug | Judge`
- [ ] Adapt existing chat component:
  - Use the selected mode when sending messages.
  - Style Quest responses as â€œQuest cardsâ€ when in Quest Mode.

Deliverable: **I can choose a track and a mode and talk to different agents from one UI.**

### Phase 1.5 â€“ Worlds & World Map

Goal: Add a â€œWorld Mapâ€ UX and organize tracks inside worlds.

**Backend**
- [ ] Add `worlds.json` and endpoints:
  - `GET /api/worlds`
  - `GET /api/worlds/{id}`
- [ ] Extend sessions to include `worldId`.

**Frontend**
- [ ] Add World Map page (`/`):
  - Grid of world cards (icon, name, description, XP).
  - â€œEnter Worldâ€ button for each.
- [ ] Add World page (`/world/:worldId`):
  - World header (name, icon, XP bar).
  - Left sidebar: tracks for this world.
  - Center: existing modes (Explain / Quest / Debug / Judge).
  - Right sidebar: Codex summary (once Codex exists).

Deliverable: **I can navigate: World Map â†’ Python World â†’ ApplyLens Backend track â†’ pick a mode.**

### Phase 2 â€“ Codex MVP

Goal: Make reference knowledge always available and organized by world.

**Backend**
- [ ] Create `codex/` folder with a few starter entries:
  - Python basics, Git basics, Prompting basics, React basics, Docker basics.
- [ ] Implement endpoints:
  - `GET /api/codex` â†’ list entries (id, title, worlds, tags).
  - `GET /api/codex/{id}` â†’ full markdown/HTML for one entry.

**Frontend**
- [ ] Add a Codex page (`/codex`):
  - Filters: by world and by tag.
  - List of entries and a viewer panel.
- [ ] Add a Codex button in the main header.
- [ ] On each World page, add a small Codex panel:
  - Show â€œPinned Codex topics for this worldâ€.
  - Clicking opens a drawer/modal with the content.

Deliverable: **I can open Codex and quickly find syntax, best practices, and stack cheat sheets without asking agents.**

### Phase 3 â€“ XP, Levels & Boss Fights

Goal: Gamify learning with measurable progress.

**Backend**
- [ ] Implement a minimal profile store: `world XP + skill XP`.
- [ ] Extend Judge mode:
  - Convert rubric scores into XP by skill.
  - Update profile after each graded answer.
- [ ] Define simple level rules: e.g. `level = floor(totalXP / 100)`.
- [ ] Add boss fight definitions:
  - Special quests with higher difficulty and stricter grading.

**Frontend**
- [ ] Show XP and level in:
  - World Map (per world).
  - World header (current world XP).
- [ ] Add â€œBoss Fightâ€ button on world pages:
  - Visible only when XP >= threshold.
- [ ] Add visual feedback when XP increases after a judged answer.

Deliverable: **I can see my progress in each world, level up, and unlock boss fights.**

### Phase 4 â€“ Better Explanations, Multi-Solutions & Visualizer

Goal: Make Explain mode truly â€œteacher-levelâ€ with multiple solution paths and diagrams.

**Backend**
- [ ] Refine Explain prompt:
  - Force a structured answer: Summary, Step-by-step, Example solution, Alternative solution(s), Common pitfalls.
- [ ] Add support for Visualizer mode:
  - System prompt that instructs the LLM to output diagrams (Mermaid/ASCII).
  - Optionally separate endpoint or mode flag (`visualize=true`).

**Frontend**
- [ ] In Explain mode, add toggles: â€œShow multiple approachesâ€, â€œShow diagramâ€.
- [ ] Render diagram output in a dedicated area (e.g., code block or diagram component).

Deliverable: **I can get clear explanations with multiple solution routes and visual aids, not just one monolithic answer.**

### Phase 5 â€“ Real Project Troubleshooting

Goal: Use EvalForge to debug real issues from ApplyLens, LedgerMind, SiteAgent, etc.

**Backend**
- [ ] (Optional/gradual) Integrate dev-only tools that fetch:
  - Recent logs / errors from ApplyLens / LedgerMind / SiteAgent.
  - Recent failed CI logs or test failures.
  - Expose these via tools that the Debugger agent can call, or via simple endpoints the UI can paste in.

**Frontend**
- [ ] In Debug mode, add quick-insert buttons:
  - â€œInsert last ApplyLens errorâ€
  - â€œInsert last LedgerMind failureâ€
  - Start with canned sample errors; move to live integration when ready.

Deliverable: **I can treat EvalForge as my â€œdebugging arenaâ€ for real systems, not just toy problems.**

### Phase 6 â€“ Multi-User / Public Demo (Optional)

Goal: Make EvalForge usable by others as a serious learning tool.

- [ ] Add basic user accounts or API tokens.
- [ ] Separate profiles and XP per user.
- [ ] Add a guided onboarding path (â€œWorld 0 â€“ Tutorialâ€).
- [ ] Polish docs and create a small marketing page that explains Worlds, Quests, and Codex.

---

## 4. Implementation Notes

- **Prefer small, incremental PRs:** One phase or sub-phase at a time.
- **Keep prompts, worlds, tracks, and codex in version control** so they evolve with the code.
- **Every new agent mode should have:**
  - A dedicated system prompt file.
  - At least one unit test and one end-to-end path (where realistic).
- **The Codex should be treated as both:**
  - A personal knowledge base.
  - A teaching tool that the agents can reference but that is also useful on its own.

This roadmap is meant to be updated as EvalForge evolves. When a phase or sub-phase is implemented, annotate it here with links to the relevant code and PRs.
